  1 /* Name: Jennifer Olszyna
  2  * Course-Section: CS 360 01, Spring 2021
  3  * Assignment: 6
  4  * Collaborators: none
  5  * Resources: Example TCP server from "Computer Networks: A Systems Approach"
  6  * Description: SERVER; string manipulation over TCP communication
  7  ------------------------------------------------------------------------------*/
  8 #include <sys/socket.h>
  9 #include <sys/select.h>
 10 #include <sys/time.h>
 11 #include <sys/types.h>
 12
 13 #include <arpa/inet.h>
 14 #include <netdb.h>
 15 #include <netinet/in.h>
 16
 17 #include <err.h>
 18 #include <signal.h>
 19 #include <stdbool.h>
 20 #include <stdint.h>
 21 #include <stdio.h>
 22 #include <stdlib.h>
 23 #include <string.h>
 24 #include <time.h>
 25 #include <unistd.h>
 26
 27 #define SERVER_PORT 5012
 28 #define MAX_CONNECTS 5
 29 #define MAX_LINE 29
 30
 31 void cleanup_exit(int);
 32
 33 //'volatile' tells complier variable is NOT static like it seems to be
 34 volatile sig_atomic_t shut_down; //global varible
 35
 36 int
 37 main(int argc, char *argv[])
 38 {
 39     struct sockaddr_in serveraddr;
 40     struct timeval tout;
 41     fd_set readFDS;
 42     char buf[MAX_LINE];
 43     time_t current_time;
 44     int buf_len;
 45     int s;
 46     int client_s;
 47
 48     shut_down = false; //set variable
 49
 50     /* build address data structure */
 51     memset(&serveraddr, '\0', sizeof serveraddr);
 52     serveraddr.sin_family = AF_INET;
 53     serveraddr.sin_addr.s_addr = INADDR_ANY;
 54     serveraddr.sin_port = htons(SERVER_PORT);
 55
 56     /* create socket s */
 57     if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
 58         errx(EXIT_FAILURE, "Socket creation error \n");
 59     }
 60
 61     /* bind socket s */
 62     if (bind(s, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0) {
 63         warnx("socket bind error \n");
 64     }
 65
 66     /* set socket s to listen */
 67     if ((listen(s, MAX_CONNECTS)) == -1) {
 68         errx(EXIT_FAILURE, "listening error");
 69     }
 70
 71     /* checking for SIGTERM; when SIGTERM caught call cleanup_exit */
 72     signal(SIGTERM, cleanup_exit);
 73
 74     /* have socket s wait and accept connecitons until shut_down; which is  triggered by SIGTERM */
 75     while (!shut_down) {
 76
 77                 /* set read file descriptors to watch socket s to see when it has input */
 78                 FD_ZERO(&readFDS);
 79                 FD_SET(s, &readFDS);
 80
 81                 /* set timeout to wait 0.25 seconds */
 82                 tout.tv_sec = 0;
 83                 tout.tv_usec = 250000;
 84
 85                 /* check for signal every .25 seconds */
 86                 client_s = select(s+1, &readFDS, NULL, NULL, &tout);
 87
 88         if (s == -1)
 89                     warnx("select(2) issue");
 90
 91                 if (s > 0) {
 92
 93                 /* receive packet(buf); */
 94             current_time = time(NULL);
 95             buf_len = snprintf(buf, sizeof buf, "%.24s\r\n", ctime(&current_time));
 96
 97                     /* send packet(buf) back to client */
 98                     send(client_s, buf, buf_len, 0);
 99
100             close(client_s);
101                 }
102     }
103
104     close(s);
105
106     return EXIT_SUCCESS;
107 }
108
109 void
110 cleanup_exit (int sig)
111 {
112     //handle sigterm
113     shut_down = true;
114 }
115